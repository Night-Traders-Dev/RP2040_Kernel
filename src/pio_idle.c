/*
 * pio_idle.c  –  CPU idle measurement + heartbeat jitter detection
 *
 * Design notes
 * ------------
 * Both PIO state machines run at clkdiv = 1.0 (full sys_clk) to preserve
 * maximum resolution.  Unit conversion uses the current sys_khz value stored
 * in s_sys_khz, which is updated by pio_idle_notify_freq_change() /
 * pio_idle_update_clkdiv() whenever the governor completes a ramp step.
 *
 * Thread safety
 * -------------
 * s_stats and the HB window are protected by a critical_section (disables
 * interrupts on the calling core for the critical section body only).
 * Both cores may call pio_idle_poll() concurrently; only one will win the
 * section on each read and the other will spin briefly.
 *
 * Settle window
 * -------------
 * After a frequency change the PLL takes a few hundred microseconds to lock.
 * During that window heartbeat readings are invalid.  s_settle_polls counts
 * down poll() calls during which jitter calculations are skipped and the HB
 * window is frozen.  SETTLE_POLLS × poll-interval should be ≥ ~5 ms.
 */

#include "pio_idle.h"
#include "hardware/pio.h"
#include "hardware/gpio.h"
#include "hardware/clocks.h"
#include "pico/time.h"
#include "pico/sync.h"
#include "dmesg.h"
#include <string.h>
#include <math.h>
#include <stdio.h>

/* Generated by pioasm from pio_idle.pio */
#include "pio_idle.pio.h"

/* -------------------------------------------------------------------------
 * Tunables
 * ------------------------------------------------------------------------- */

/** EMA weight for idle_fraction update (higher = faster response). */
#define IDLE_EMA_ALPHA      0.15f

/** Heartbeat rolling-window length (number of samples). */
#define HB_WIN_LEN          8u

/**
 * Number of pio_idle_poll() calls to skip jitter assessment after a
 * frequency change.  At a ~1 ms poll interval this is ~8 ms settle time.
 */
#define SETTLE_POLLS        8

/**
 * A heartbeat window is declared "stable" when its coefficient of variation
 * (stddev / mean × 100 %) falls below this threshold.
 */
#define STABLE_CV_PCT       1.5f

/**
 * Main-loop nominal period used as the denominator when computing the
 * idle fraction from a single idle measurement.
 * The Core 0 loop sleeps 100 µs and refreshes stats every ~500 µs,
 * giving roughly 600 µs per iteration at idle.
 */
#define LOOP_PERIOD_US      600.0f

/* -------------------------------------------------------------------------
 * Module state
 * ------------------------------------------------------------------------- */

static PIO  s_pio     = pio0;
static uint s_sm_idle;
static uint s_sm_hb;
static bool s_inited  = false;

/** Current sys_khz, used for ticks→µs conversion.  Volatile so Core 1
 *  writes are visible to Core 0 reads in poll() without locks. */
static volatile uint32_t s_sys_khz;

/** Counts down to 0 after a freq change; jitter calc is suppressed while > 0. */
static volatile int32_t  s_settle_polls = 0;

/* Heartbeat rolling window (protected by s_cs) */
static uint32_t s_hb_win[HB_WIN_LEN];
static uint8_t  s_hb_wi   = 0;
static uint8_t  s_hb_wcnt = 0;

/* Published stats snapshot */
static pio_idle_stats_t s_stats;

/* Protects s_stats and s_hb_win; held only for pointer-sized copies. */
static critical_section_t s_cs;

/* -------------------------------------------------------------------------
 * Internal helpers
 * ------------------------------------------------------------------------- */

static inline void cs_enter(void) { critical_section_enter_blocking(&s_cs); }
static inline void cs_exit(void)  { critical_section_exit(&s_cs); }

/**
 * Compute the coefficient of variation (%) of the current HB window.
 * Returns 100 % if fewer than 2 samples are available (= unstable).
 * Caller must hold s_cs.
 */
static float hb_window_cv_pct(void)
{
    if (s_hb_wcnt < 2) return 100.0f;

    /* Mean */
    float sum = 0.0f;
    for (uint8_t i = 0; i < s_hb_wcnt; ++i)
        sum += (float)s_hb_win[i];
    float mean = sum / (float)s_hb_wcnt;
    if (mean < 1.0f) return 100.0f;

    /* Variance */
    float var = 0.0f;
    for (uint8_t i = 0; i < s_hb_wcnt; ++i) {
        float d = (float)s_hb_win[i] - mean;
        var += d * d;
    }
    var /= (float)s_hb_wcnt;

    return sqrtf(var) / mean * 100.0f;
}

/* -------------------------------------------------------------------------
 * Public API – lifecycle
 * ------------------------------------------------------------------------- */

void pio_idle_init(void)
{
    if (s_inited) return;

    critical_section_init(&s_cs);
    memset(&s_stats,  0, sizeof(s_stats));
    memset(s_hb_win,  0, sizeof(s_hb_win));

    s_sys_khz = clock_get_hz(clk_sys) / 1000u;

    /* ---- Configure Core 0 output pins ---------------------------------- */
    gpio_init(PIO_IDLE_PIN);
    gpio_set_dir(PIO_IDLE_PIN, GPIO_OUT);
    gpio_put(PIO_IDLE_PIN, 0);

    gpio_init(PIO_HB_PIN);
    gpio_set_dir(PIO_HB_PIN, GPIO_OUT);
    gpio_put(PIO_HB_PIN, 0);

    /* ---- Load PIO programs --------------------------------------------- */
    /* Both programs fit comfortably in PIO0's 32-instruction program memory.
     * idle_measure = 7 instructions, period_measure = 8 instructions. */
    uint off_idle = pio_add_program(s_pio, &idle_measure_program);
    uint off_hb   = pio_add_program(s_pio, &period_measure_program);

    /* ---- Claim state machines ------------------------------------------ */
    s_sm_idle = pio_claim_unused_sm(s_pio, true);
    s_sm_hb   = pio_claim_unused_sm(s_pio, true);

    /* ---- Init and start both SMs --------------------------------------- */
    idle_measure_program_init(  s_pio, s_sm_idle, off_idle, PIO_IDLE_PIN);
    period_measure_program_init(s_pio, s_sm_hb,   off_hb,   PIO_HB_PIN);

    s_inited = true;

    char buf[96];
    snprintf(buf, sizeof(buf),
             "pio_idle: init OK pio0 SM%u=idle(pin%u) SM%u=hb(pin%u) @%ukHz",
             s_sm_idle, PIO_IDLE_PIN, s_sm_hb, PIO_HB_PIN, s_sys_khz);
    dmesg_log(buf);
}

/* -------------------------------------------------------------------------
 * Public API – unit conversion
 * ------------------------------------------------------------------------- */

float pio_idle_ticks_to_us(uint32_t ticks, uint32_t sys_khz)
{
    if (sys_khz == 0) return 0.0f;
    /*  1 tick = 2 sys-clock cycles  (jmp pin + jmp x-- per loop iteration)
     *  us = ticks × 2 / (sys_khz × 1000 / 1 000 000)
     *     = ticks × 2 000 000 / (sys_khz × 1000)
     *     = ticks × 2000 / sys_khz
     */
    return (float)ticks * 2000.0f / (float)sys_khz;
}

/* -------------------------------------------------------------------------
 * Public API – frequency-change integration
 * ------------------------------------------------------------------------- */

void pio_idle_notify_freq_change(uint32_t new_khz)
{
    /* Order matters: update conversion factor first, then reset window. */
    s_sys_khz     = new_khz;
    s_settle_polls = SETTLE_POLLS;

    cs_enter();
    memset(s_hb_win, 0, sizeof(s_hb_win));
    s_hb_wi              = 0;
    s_hb_wcnt            = 0;
    s_stats.stable_count = 0;
    s_stats.safe_to_scale = false;
    cs_exit();

    char buf[72];
    snprintf(buf, sizeof(buf),
             "pio_idle: freq_change %ukHz settle=%d polls", new_khz, SETTLE_POLLS);
    dmesg_log(buf);
}

void pio_idle_update_clkdiv(uint32_t sys_khz)
{
    /*
     * We keep clkdiv = 1.0 (maximum resolution) and rely on software
     * conversion.  If you want a fixed-rate timebase independent of
     * sys_clk changes, set a clkdiv here:
     *
     *   #define TARGET_PIO_KHZ  1000u   // 1 MHz fixed timebase
     *   float div = (float)sys_khz / (float)TARGET_PIO_KHZ;
     *   pio_sm_set_clkdiv(s_pio, s_sm_idle, div);
     *   pio_sm_set_clkdiv(s_pio, s_sm_hb,   div);
     *   uint32_t mask = (1u << s_sm_idle) | (1u << s_sm_hb);
     *   pio_sm_clkdiv_restart(s_pio, mask);
     *
     * With a fixed clkdiv the conversion factor becomes constant and you
     * no longer need to call this function after each ramp step.
     */
    s_sys_khz = sys_khz;
}

/* -------------------------------------------------------------------------
 * Public API – FIFO polling  (Core 0 or Core 1, non-blocking)
 * ------------------------------------------------------------------------- */

void pio_idle_poll(void)
{
    if (!s_inited) return;

    const uint32_t sys_khz = s_sys_khz; /* local snapshot, no lock needed */

    /* ------------------------------------------------------------------ */
    /* SM0 – idle_measure : drain RX FIFO                                  */
    /* ------------------------------------------------------------------ */
    while (!pio_sm_is_rx_fifo_empty(s_pio, s_sm_idle)) {
        uint32_t ticks = pio_sm_get(s_pio, s_sm_idle); /* non-blocking */

        float idle_us = pio_idle_ticks_to_us(ticks, sys_khz);

        /* Clamp and compute fraction relative to one main-loop iteration. */
        float frac = idle_us / LOOP_PERIOD_US;
        if (frac < 0.0f) frac = 0.0f;
        if (frac > 1.0f) frac = 1.0f;

        cs_enter();
        s_stats.idle_ticks    = ticks;
        /* Exponential moving average keeps the fraction smooth. */
        s_stats.idle_fraction = s_stats.idle_fraction * (1.0f - IDLE_EMA_ALPHA)
                              + frac * IDLE_EMA_ALPHA;
        cs_exit();
    }

    /* ------------------------------------------------------------------ */
    /* SM1 – period_measure : drain RX FIFO, compute jitter & stability    */
    /* ------------------------------------------------------------------ */
    while (!pio_sm_is_rx_fifo_empty(s_pio, s_sm_hb)) {
        uint32_t period = pio_sm_get(s_pio, s_sm_hb);

        /* 0 is the overflow sentinel emitted when x wraps; discard it. */
        if (period == 0) continue;

        cs_enter();

        /* ---- Save raw sample ---- */
        uint32_t prev             = s_stats.hb_period_ticks;
        s_stats.hb_period_prev    = prev;
        s_stats.hb_period_ticks   = period;

        /* ---- Settle window: skip jitter calc during PLL lock ---- */
        if (s_settle_polls > 0) {
            s_settle_polls--;
            cs_exit();
            continue;
        }

        /* ---- Jitter: signed delta vs previous sample ---- */
        if (prev > 0) {
            int32_t delta          = (int32_t)period - (int32_t)prev;
            s_stats.hb_jitter_ticks = delta;
            s_stats.hb_jitter_pct  =
                fabsf((float)delta) / (float)prev * 100.0f;
        } else {
            s_stats.hb_jitter_ticks = 0;
            s_stats.hb_jitter_pct  = 0.0f;
        }

        /* ---- Rolling window ---- */
        s_hb_win[s_hb_wi] = period;
        s_hb_wi = (uint8_t)((s_hb_wi + 1u) % HB_WIN_LEN);
        if (s_hb_wcnt < HB_WIN_LEN) s_hb_wcnt++;

        /* ---- Stability: coefficient of variation of window ---- */
        float cv = hb_window_cv_pct();
        if (cv < STABLE_CV_PCT) {
            if (s_stats.stable_count < UINT32_MAX)
                s_stats.stable_count++;
        } else {
            s_stats.stable_count = 0;
        }

        /* ---- Update cached safe_to_scale flag ---- */
        s_stats.safe_to_scale =
            (s_stats.stable_count >= 4u) &&
            (s_stats.hb_jitter_pct <= 3.0f || prev == 0);

        cs_exit();
    }
}

/* -------------------------------------------------------------------------
 * Public API – snapshot
 * ------------------------------------------------------------------------- */

void pio_idle_get_stats(pio_idle_stats_t *out)
{
    if (!out) return;
    cs_enter();
    *out = s_stats;
    cs_exit();
}

/* -------------------------------------------------------------------------
 * Public API – governor arbiter
 * ------------------------------------------------------------------------- */

bool pio_idle_safe_to_scale(float idle_thresh, float jitter_thresh,
                            uint32_t min_stable)
{
    /* If PIO subsystem is uninitialised never block the governor. */
    if (!s_inited) return true;

    cs_enter();
    pio_idle_stats_t snap = s_stats;
    cs_exit();

    /*
     * Primary gate: the heartbeat has been stable for at least min_stable
     * consecutive samples AND the most-recent jitter is within bounds.
     *
     * The idle fraction is a secondary hint: if the CPU is genuinely
     * idle we can be more aggressive; if it's busy we prefer to wait
     * for full stability.
     */
    bool stable     = (snap.stable_count >= min_stable);
    bool low_jitter = (snap.hb_jitter_pct <= jitter_thresh || snap.hb_period_prev == 0);
    bool idle_hint  = (snap.idle_fraction  >= idle_thresh);

    /* Safe if: stable AND jitter OK.
     * Also safe if: very stable (2× threshold) even if idle fraction is low.
     */
    if (stable && low_jitter) return true;
    if (snap.stable_count >= (min_stable * 2u)) return true;
    (void)idle_hint;   /* could be used to tighten gate: idle_hint && stable */
    return false;
}
